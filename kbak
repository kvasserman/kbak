#!/bin/bash

set -eo pipefail

# Functions

function usage() {
    local msg="$1"
    local exitcode=$2

    local output=2

    [ -z "$msg" ] || (printf "\nERROR: $msg\n\nUse -h or --help for usage\n" 1>&2; exit 1)
    [ -z "$exitcode" ] && exitcode=1
    [ $exitcode -eq 0 ] && output=1

    cat 1>&$output <<EOF

$myname v$myver

Usage:
    Backup:
        form 0 (stdin gzipped to stdout)
            $myname
        form 0.1 (stdin sent gzipped to stdout with progress)
            $myname -p
        form 1 (full backup of a file, directory or block device)
            $myname -s <FILE|DIR|BLOCK-DEV> [<TARGET-FILE>]
        form 2 (full backup of standard input)
            $myname [<TARGET-FILE>]
        form 3 (differential backup of a file, directory or block device)
            $myname -d -s <FILE|DIR|BLOCK-DEV> -r <FULL-FILE> [<TARGET-FILE>]
        form 4 (differential backup of standard input)
            $myname -d -r <FULL-FILE> [<TARGET-FILE>]
    Restore:
        form 5 (restore a file. ungzip it)
            $myname --restore -s <FILE> [<TARGET-FILE|TARGET-DIR>]
        form 6 (restore a differential backup of a file)
            $myname --restore -s <DIFF-FILE> -r <FULL-FILE> [<TARGET-FILE|TARGET-DIR>]

    -f, --full                      full backup mode (default)
    -d, --diff, --differential      differential backup mode
    -x, --restore                   restore mode
        --info                      show backup information about source file
    -r, --reference <full-backup>   full backup file to reference for differential backup/restore
    -s, --source <source>           source to backup. a file, a directory or a block device
                                    in restore mode source is full-backup or diff file
    -k, --key <rsa-private-key>     RSA private key file to encrypt/decrypt the backup                            
    -p, --progress                  show progress
    -q, --quiet                     don't output normal messages (disables progress)
    -h, --help                      this help

    NOTE: In restore mode the target must be a directory if the backup was of a directory
EOF
    exit $exitcode
}

shortopts='fdr:s:k:pqxh'
longopts='full,diff,differential,reference:,source:,key:,progress,quiet,restore,help,info'

function processOptions() {
    while true; do
        case "$1" in
            -f|--full)
                [ -z "$mode" ] || usage "Choose one mode: --full, --differential, --restore or --info"
                mode='full'
                shift;;
            -d|--diff|--differential)
                [ -z "$mode" ] || usage "Choose one mode: --full, --differential, --restore or --info"
                mode='diff'
                shift;;
            -x|--restore)
                [ -z "$mode" ] || usage "Choose one mode: --full, --differential, --restore or --info"
                mode='restore'
                shift;;
            --info)
                [ -z "$mode" ] || usage "Choose one mode: --full, --differential, --restore or --info"
                mode='info'
                shift;;
            -s|--source)
                src="$2"
                shift 2;;
            -r|--reference)
                ref="$2"
                shift 2;;
            -k|--key)
                rsakey="$2"
                shift 2;;
            -p|--progress)
                progress=1
                shift;;
            -q|--quiet)
                progress=0
                quiet=1
                shift;;
            -h|--help)
                usage '' 0;;
            --) 
                shift 

                [ -z "$1" ] || tgt="$1"

                [ -z "$mode" ] && mode='full'

                if [[ "$mode" == 'restore' || "$mode" == 'info' ]]; then
                    [[ "$src" == '-' || -f "$src" ]] || usage "Source must be stdin or an existing file. Provided '$src'"
                else
                    [[ "$src" == '-' || -f "$src" || -d "$src" || -b "$src" ]] || usage "Source must be stdin or an existing file, directory or block device. Provided '$src'"
                fi

                [[ "$tgt" == '-' || ! -f "$tgt" ]] || usage "Target file '$tgt' already exists"
                [[ "$tgt" == '-' || -d "$(dirname "$tgt")" ]] || usage "Target directory '$(dirname "$tgt")' doesn't exist"

                [[ "$mode" != 'diff' || -f "$ref" ]] || usage "Reference file '$ref' doesn't exist"
                [[ "$src" != "$ref" ]] || usage "Reference file must be different from source"
                [[ -z "$rsakey" || -f "$rsakey" ]] || usage "Key must be a file"
                [ -z "$rsakey" ] || openssl rsa -check -in "$rsakey" -noout &>/dev/null || usage "Key must be a valid RSA private key"
                break;;
            *)
                usage "Unknown option: $1";;
        esac
    done
}

function msg() {
    [ $quiet -eq 1 ] || echo "$1" 1>&2
}

function addToPipe() {
    local delim='|'

    [ -z "$2" ] || delim="$2"

    [ -z "$command" ] || command+=" $delim "
    command+="$1"
}

function createHeader() {
    local refid="$1"
    local keysha="$2"
    local sha256="$3"

    [ -z "$refid" ] && refid="$(printf '%036d' 0)"
    [ -z "$keysha" ] && keysha="$(printf '%064d' 0)"
    [ -z "$sha256" ] && sha256="$(printf '%064d' 0)"

    # kbak    4   0-3       signature
    # fver    4   4-7       file version
    # mode    4   8-11      full or diff
    # id      36  12-47     unique id
    # refid   36  48-83     unique id of reference
    # tstamp  12  84-95     timestamp
    # keysha  64  96-159    sha256 of public key
    # sha256  64  160-223   sha256 of content
    # reserve 288 224-511   reserved space
    local format='%.4s%04x%.4s%36s%36s%012x%64s%64s%288s'
    local reserve="$(printf '%0288d' 0)"

    printf "$format" "$sig" $filever $mode "$(uuidgen)" "$refid" $(date -u +%s) "$keysha" "$sha256" "$reserve"
}

function getHeaderPart() {
    local header="$1"
    local key="$2"
    local s=0
    local l=0

    case "$key" in
        sig) s=0; l=4;;
        fver) s=4; l=4;;
        mode) s=8; l=4;;
        id) s=12; l=36;;
        refid) s=48; l=36;;
        tstamp) s=84; l=12;;
        keysha) s=96; l=64;;
        sha256) s=160; l=64;;
    esac 

    printf "${header:$s:$l}"
}

function getHeader() {
    local file="$1"
    local ifc=''
    local hlen="$(createHeader | wc -c)"

    [ "$file" == '-' ] || ifc="if='$file'"
    local header="$(eval "dd bs=$hlen count=1 status=none $ifc | cat -A")" # cat -A to avoid null byte issues

    [ ${#header} -eq $hlen ] || msg "File '$file' has an invalid $myname signature"

    local fsig="$(getHeaderPart "$header" sig)"
    [ "$fsig" == "$sig" ] || (msg "'$file' doesn't appear to be $myname file"; exit 1)

    local fver="$(getHeaderPart "$header" fver)"
    printf "$fver" | grep -P '^[\da-f]{4}$' &>/dev/null || (msg "Unknown $myname file version: $(printf "$fver" | cat -A)"; exit 1)
    case "$((16#$fver))" in 
        $filever) ;;
        *)
            msg "Unknown $myname file version: $(printf "$fver" | cat -A)"
            exit 1;;
    esac
    printf "$header"
}

function showInfo() {
    local header="$(getHeader "$1")"

    local ts=$((16#$(getHeaderPart "$header" tstamp)))
    local refid="$(getHeaderPart "$header" refid)"
    local keysha="$(getHeaderPart "$header" keysha)"
    local sha256="$(getHeaderPart "$header" sha256)"

    [ -z "$(printf "$refid" | sed 's/0//g')" ] && refid='n/a'
    [ -z "$(printf "$keysha" | sed 's/0//g')" ] && keysha='n/a'
    [ -z "$(printf "$sha256" | sed 's/0//g')" ] && sha256='n/a'
    
    cat <<EOF
Source file:                $1
File Version:               $((16#$(getHeaderPart "$header" fver)))
Backup Type:                $(getHeaderPart "$header" mode)
Backup Id:                  $(getHeaderPart "$header" id)
Reference Backup Id:        $refid
UTC Backup Time:            $(date -u -d @$ts)
Local Backup Time:          $(date -d @$ts)
Key Signature:              $keysha
Content SHA256 Hash:        $sha256
EOF
}

# End Functions

# Main

# global constants
myname=$(basename "$0")
myver='1.1'
filever=1
sig='kbak'

#defaults
mode=''
src='-'
tgt='-'
ref=''
progress=0
quiet=0
rsakey=''
pass=''
refpass=''
skipbytes=0
refskipbytes=0

parsedparams=$(getopt -n "$myname" -o "$shortopts" -l "$longopts" -- "$@")
eval set -- "$parsedparams"

processOptions "$@"

if [ "$mode" == 'info' ]; then
    showInfo "$src"
    exit 0
fi

msg "Mode: $mode. '$src' => '$tgt' (reference '$ref')"

command=''

# deal with headers
keysig=''
[ -z "$rsakey" ] || keysig="$(openssl pkey -pubout -in "$rsakey" -outform der | sha256sum | cut -d' ' -f1)"

if [ "$mode" == 'restore' ]; then
    fheader="$(getHeader "$src")"
    
    fid="$(getHeaderPart "$fheader" id)"
    fmode="$(getHeaderPart "$fheader" mode)"
    frefid="$(getHeaderPart "$fheader" refid)"
    fkeysig="$(getHeaderPart "$fheader" keysha)"

    [[ -z "$rsakey" || "$keysig" == "$fkeysig" ]] || (msg "File '$src' is not encrypted with the provided key."; exit 1)
    [[ "$fmode" == 'diff' && -z "$ref" ]] && (msg "Source is a differential backup, but reference to full backup is not provided."; exit 1)
    [[ "$fmode" == 'full' && ! -z "$ref" ]] && (msg "Source is a full backup, but reference is also provided."; exit 1)

    refid=''
    if [ ! -z "$ref" ]; then 
        refheader="$(getHeader "$ref")"
        refmode="$(getHeaderPart "$refheader" mode)"
        refid="$(getHeaderPart "$refheader" id)"
        refkeysig="$(getHeaderPart "$refheader" keysha)"

        [[ "$refmode" != 'full' ]] && (msg "Reference is not a full backup."; exit 1)
        [[ -z "$rsakey" || "$keysig" == "$refkeysig" ]] || (msg "File '$ref' is not encrypted with the provided key."; exit 1)
        [[ "$frefid" != "$refid" ]] && (msg "Reference '$ref' is not the reference that was used to create source diff backup."; exit 1)

        refskipbytes=$(($refskipbytes + ${#refheader}))
    fi

    skipbytes=${#fheader}

else
    refid=''
    if [ "$mode" == 'diff' ]; then 
        refheader="$(getHeader "$ref")"
        refid="$(getHeaderPart "$refheader" id)"
        refskipbytes=$(($refskipbytes + ${#refheader}))
    fi
    
    newheader=$(createHeader "$refid" "$keysig")
    hlen=${#newheader}
    cmd="printf '$newheader' | dd bs=$hlen count=1 status=none"
    [ "$tgt" == '-' ] || cmd+=" of='$tgt'"
    eval "$cmd"
fi

# figure out the encryption keys
if [ ! -z "$rsakey" ]; then
    if [ "$mode" == 'restore' ]; then

        keysize=$(printf 'x' | openssl pkeyutl -encrypt -inkey "$rsakey" | wc -c)

        # msg 'Decrypting password'
        kcmd="dd bs=1 count=$keysize status=none"
        [ "$src" != '-' ] && kcmd+=" if='$src' skip=$skipbytes"
        pass=$(eval "$kcmd" | openssl pkeyutl -decrypt -inkey "$rsakey")

        if [ ! -z "$ref" ]; then
            refkeysize=$(printf 'x' | openssl pkeyutl -encrypt -inkey "$rsakey" | wc -c)

            # msg 'Decrypting reference password'
            refpass=$(dd bs=1 count=$refkeysize skip=$refskipbytes status=none if="$ref" | openssl pkeyutl -decrypt -inkey "$rsakey")

            refskipbytes=$(($refskipbytes + $refkeysize))
        fi

        skipbytes=$(($skipbytes + $keysize))

    else
        # msg 'Generating random password'
        pass='test' # $(openssl rand 50 | base64 -w0)

        # msg "Encrypting and storing password"
        kcmd="printf '$pass' | openssl pkeyutl -encrypt -inkey '$rsakey'"
        [ "$tgt" != '-' ] && kcmd+=" >> '$tgt'"
        eval "$kcmd"

        if [ "$mode" == 'diff' ]; then
            refkeysize=$(printf 'x' | openssl pkeyutl -encrypt -inkey "$rsakey" | wc -c)

            # msg "Decrypting reference password"
            refpass=$(dd bs=1 count=$refkeysize skip=$refskipbytes status=none if="$ref" | openssl pkeyutl -decrypt -inkey "$rsakey")

            refskipbytes=$(($refskipbytes + $refkeysize))
        fi
    fi
fi

# input
if [  "$src" == '-' ]; then
    [ $progress -eq 1 ] && addToPipe "pv -petr" 
elif [[ -f "$src" || -b "$src" ]]; then
    [ $skipbytes -gt 0 ] && addToPipe "dd bs=$skipbytes skip=1 if='$src' status=none" || addToPipe "cat '$src'"
    if [ $progress -eq 1 ]; then
        filesize=''
        if [ -f "$src" ]; then
            filesize=$(stat --printf='%s' "$src")
        else
            filesize=$(blockdev --getsize64 "$src")
        fi
        [ $skipbytes -gt 0 ] && filesize=$(($filesize - $skipbytes))
        filesize="s $filesize"
        addToPipe "pv -petr${filesize}"
    fi
else
    [ $progress -eq 1 ] && addToPipe "tar -cvS '$src'" || addToPipe "tar -cS '$src'"
fi

# decryption
# only needed if key is provided and it's restore
[[ ! -z "$rsakey" && "$mode" == 'restore' ]] && addToPipe "openssl enc -d -aes256 -iter 10000 -pass file:<(printf '$pass')"

# decompression
[ "$mode" == 'restore' ] && addToPipe "gzip -dc"

# delta
# full backup doesn't need any diffing or undiffing
refdecryptcmd=''
[ -z "$rsakey" ] || refdecryptcmd="| openssl enc -d -aes256 -iter 10000 -pass file:<(printf '$refpass')"
if [ "$mode" == 'diff' ]; then
    addToPipe "xdelta3 -ecRqA -s <(dd bs=$refskipbytes skip=1 status=none if='$ref' $refdecryptcmd | gzip -dc || kill $$)"
elif [[ "$mode" == 'restore' && ! -z "$ref" ]]; then
    addToPipe "xdelta3 -dcRqA -s <(dd bs=$refskipbytes skip=1 status=none if='$ref' $refdecryptcmd | gzip -dc || kill $$)"
fi

# untar
# only needed if mode is restore and target is a directory
if [[ "$mode" == 'restore' && -d "$tgt"  ]]; then
	if [ $progress -eq 1 ]; then
		addToPipe "tar -xv -C '$tgt'"
	else
		addToPipe "tar -x -C '$tgt'"
	fi
fi

# compression
# only needed for mode full and diff
[ "$mode" == 'restore' ] || addToPipe "gzip -c"

# encryption
# only needed for mode full and diff
[[ -z "$rsakey" || "$mode" == 'restore' ]] || addToPipe "openssl enc -e -aes256 -pbkdf2 -iter 10000 -pass file:<(printf '$pass')"

# sha calc
tempsha=''
if [[ "$mode" != 'restore' && "$tgt" != '-' ]]; then
    tempsha=$(mktemp)
    addToPipe "tee >(sha256sum | cut -d' ' -f1 > '$tempsha' || kill $$)"
fi

#output
if [ "$tgt" != '-' ]; then 
    # restore to directory is handled by untar (above)
    [[ "$mode" == 'restore' && -d "$tgt" ]] || addToPipe "'$tgt'" '>>'
fi

# show the thing
# msg "$command"

# run the thing
eval "$command"

if [ -f "$tempsha" ]; then
    # update target header with content hash
    hash=$(cat "$tempsha")
    printf "$hash" | dd bs=1 count=64 seek=160 conv=notrunc of="$tgt" status=none
    rm "$tempsha"
fi

msg "Done"